<style>
    .centre {
        display: flex;
        justify-content: center;
        align-items: end;
        height: 100%;
    }
    #chatContainer {
        transition: all .25s linear;
        margin: 17px;
        width: 90%;
        z-index: 1;
    }

    #messages {
        height: 100%;
        width: 100%;
        top: 0;
        left: 0;
        position: absolute;
        overflow-y: scroll;
    }
    .out {
        height: fit-content;
        display: flex;
        padding: 0px 10px;
    }
    .myOut {
        justify-content: end;
    }
    .in {
        position: relative;
        display: flex;
        align-items: center;
        border-radius: 10px;
        padding: 10px;
    }
    .in > span {
        max-width: 100%;
    }
    .myIn {
        background-color: rgba(var(--accent-1-strong-rgb), 0.5);
    }
    .botIn {
        background-color: rgba(var(--accent-2-strong-rgb), 0.5);
    }
    .animateFont {
        transition: all .25s var(--transition);
        transform: scaleX(0);
    }
    .anim {
        transform: scaleX(1);
    }

    .in:has(div[contenteditable=true]) {
        border-radius: 15px;
        display: flex;
        flex-direction: column;
        align-items: end;
        padding-bottom: 0;
    }
    .in:has(div[contenteditable=true]):focus {
        box-shadow: 0 0 0 3px rgba(var(--accent-2-strong-rgb), 0.8);
    }
    .in > div[contenteditable=true] {
        box-shadow: 0 0 0 2px rgba(var(--accent-2-strong-rgb), 0.5);
        border-radius: 10px;
        background-color: whitesmoke;
        margin: 10px;
        padding: 5px;
        display: flex;
        flex-direction: column;
        margin-bottom: 0;
    }
    .in > div[contenteditable=true] + div {
        margin-right: 15px;
    }
    .msgEditBtn {
        background-color: rgba(var(--hov-rgb), 0.12);
        margin: 8px 4px;
        padding: 8px 10px;
        border-radius: 15px;
    }
    .msgEditBtn:hover {
        background-color: rgba(var(--active-rgb), 0.25);
    }
    .msgEditBtn:active {
        background-color: rgba(var(--accent-1-dark-rgb), 0.45);
    }

    .pfpParent {
        position: relative;
        height: fit-content;
    }
    .pfp {
        width: 50px;
        height: 50px;
        border-radius: 50%;
        margin-right: 10px;
        background-color: black;
        object-fit: cover;
    }
    .pfpParent > .tooltip {
        width: max-content;
        left: 0;
        bottom: calc(100% + 10px);
    }

    .msgcontainer {
        max-width: 60%;
        width: fit-content;
    }
    .myCont {
        display: flex;
        flex-direction: column;
        align-items: end;
    }

    .buttons {
        margin: 0px 5px;
        display: flex;
        min-width: fit-content;
    }
    .myButtons {
        justify-content: end;
        /*flex-direction: row-reverse;*/
    }
    .chatBtn {
        margin: 5px 2px;
        position: relative;
    }

    #goToBottom {
        height: fit-content;
        pointer-events: initial;
    }
    #goToBottomContainer {
        position: absolute;
        bottom: 0;
        left: 0;
        width: 100%;
        justify-content: center;
        display: flex;
        pointer-events: none;
    }
</style>

<div id="messages" onscroll="onScrollMsgs()">
    <div id="messageBubbles"><br></div>
    <div id="spacer"></div>
</div>
<div id="goToBottomContainer">
    <button id="goToBottom" onclick="scrollMsgs()">ðŸ¡‡</button>
</div>
<div class="centre">
    <div id="AIchatButtons" class="buttons">
        <div class="chatBtn" onclick="redo(this)" role="button" tabindex="0">
            <svg width="18" height="18">
                <use href="#redo" />
            </svg>
            <div class="tooltip"><b>Redo</b></div>
        </div>
        <div class="chatBtn" onclick="backElm(this)" role="button" tabindex="0">
            <svg width="18" height="18">
                <use href="#backspace" />
            </svg>
            <div class="tooltip"><b>Delete</b><br>this</div>
        </div>
        <div class="chatBtn" onclick="delElm(this)" role="button" tabindex="0">
            <svg width="18" height="18">
                <use href="#delete" />
            </svg>
            <div class="tooltip"><b>Delete</b><br>All next</div>
        </div>
    </div>
    <div id="MychatButtons" class="buttons myButtons">
        <div class="chatBtn" onclick="redo(this, 1)" role="button" tabindex="0">
            <svg width="18" height="18">
                <use href="#redo" />
            </svg>
            <div class="tooltip"><b>Redo</b></div>
        </div>
        <div class="chatBtn" onclick="editElm(this)" role="button" tabindex="0">
            <svg width="18" height="18">
                <use href="#editText" />
            </svg>
            <div class="tooltip"><b>Edit</b></div>
        </div>
        <div class="chatBtn" onclick="backElm(this)" role="button" tabindex="0">
            <svg width="18" height="18">
                <use href="#backspace" />
            </svg>
            <div class="tooltip"><b>Delete</b><br>this</div>
        </div>
        <div class="chatBtn" onclick="delElm(this)" role="button" tabindex="0">
            <svg width="18" height="18">
                <use href="#delete" />
            </svg>
            <div class="tooltip"><b>Delete</b><br>All next</div>
        </div>
    </div>
    <script>
        insertTemplate(document.currentScript.parentElement, 'chatContainer');
        unuseTemplate('AIchatButtons');
        unuseTemplate('MychatButtons');

        var CONV = [];

        var PFPCache = {};
        async function getPfp(pfpElm, pfp) {
            if (!pfp) {
                pfpElm.firstElementChild.src = '';
                pfpElm.lastElementChild.innerText = '';
                return;
            }
            var displTxt = pfp[0];
            if (pfp.length > 1) {
                displTxt += '\n'+pfp.slice(1).join('\n');
            }
            pfpElm.lastElementChild.innerText = displTxt;
            if (PFPCache[pfp]) {
                if (PFPCache[pfp] !== 'null') {
                    pfpElm.firstElementChild.src = PFPCache[pfp];
                }
                return;
            }
            var resp = await fetch('/proxy/google?q='+encode(`${pfp[pfp.length-1].replace(' ', '+')}+ai+icon+svg+-huggingface`))
                .finally(()=>{PFPCache[pfp] = 'null'});
            var text = await resp.text();
            const parser = new DOMParser();
            const doc = parser.parseFromString(text, "text/html");

            const links = doc.querySelectorAll('img');
            if (links.length > 0) {
                var url = links[1].src;
                pfpElm.firstElementChild.src = url;
                PFPCache[pfp] = url;
                return;
            }
        }

        function makeMessage(role, content, animate = true, pfp = '') {
            var out = document.createElement('div');
            out.classList.add('out');

            if (role === 'bot') {
                var pfpElm = document.createElement('div');
                pfpElm.classList.add('pfpParent');

                var pfpImg = document.createElement('img');
                pfpImg.classList.add('pfp');
                pfpElm.appendChild(pfpImg);
                
                var pfpTooltip = document.createElement('div');
                pfpTooltip.classList.add('tooltip');
                pfpElm.appendChild(pfpTooltip);

                getPfp(pfpElm, pfp);
                out.appendChild(pfpElm);
            }

            var container = document.createElement('div');
            container.classList.add('msgcontainer')
            if (role === 'user') {
                container.classList.add('myCont');
            }

            var buttons;
            if (role === 'user') {
                buttons = copyTemplate('MychatButtons');
            } else {
                buttons = copyTemplate('AIchatButtons');
            }

            var inn = document.createElement('div');
            inn.classList.add('in');
            if (role === 'user') {
                out.classList.add('myOut');
                inn.classList.add('myIn');
            } else {
                inn.classList.add('botIn');
            }
            if (animate) {
                inn.classList.add('animateFont');
                setTimeout(function(){
                    inn.classList.add('anim');
                }, 1)
            }
            var span = document.createElement('span');
            formatText(span, content)
            inn.appendChild(span);
            container.appendChild(inn);
            container.appendChild(buttons);
            out.appendChild(container);
            document.getElementById('messageBubbles').appendChild(out);
            return out;
        }

        async function addMessage(role, content, pfp = '') {
            const ID = this.location.pathname.split('/')[2];
            var newConv = CONV;
            newConv.push({
                'role': role,
                'content': content,
                'pfp': pfp
            });

            resp = await fetch('/api/v1/chat/'+ID, {
                method: 'PUT',
                headers: {
                    'Content-Type': 'application/json'
                },
                body: JSON.stringify({
                    'conv': CONV
                })
            });
            json = await resp.json();
            if (json.status === 'error') {
                console.error(json);
                alert(json.message);
                return;
            }
            CONV = json.data.messages;
            return makeMessage(role, content, pfp=pfp);
        }

        async function updateLastMessage(newContent, pfp) {
            const ID = this.location.pathname.split('/')[2];
            var newConv = CONV;
            newConv[newConv.length - 1].content = newContent;
            if (newConv[newConv.length - 1].pfp !== pfp) {
                var pfpElm = document.getElementById('messageBubbles').lastElementChild.firstElementChild;
                getPfp(pfpElm, pfp);
            }
            newConv[newConv.length - 1].pfp = pfp;

            resp = await fetch('/api/v1/chat/'+ID, {
                method: 'PUT',
                headers: {
                    'Content-Type': 'application/json'
                },
                body: JSON.stringify({
                    'conv': newConv
                })
            });
            json = await resp.json();
            if (json.status === 'error') {
                console.error(json);
                alert(json.message);
                return;
            }
            CONV = json.data.messages;
        }

        var scrlAtBtm = true;
        var waitingForScrl = false;
        var interruptScrlWait = false;
        let userScrolling = false;

        function setUserScrolling() {
            userScrolling = true;
            setTimeout(() => (userScrolling = false), 100);
        }

        document.getElementById('messages').addEventListener('wheel', setUserScrolling);
        document.getElementById('messages').addEventListener('touchmove', setUserScrolling);
        document.getElementById('messages').addEventListener('keydown', (event) => {
            if (['ArrowUp', 'ArrowDown', 'PageUp', 'PageDown', 'Home', 'End', 'Space'].includes(event.key)) {
                setUserScrolling();
            }
        });
        function onScrollMsgs() {
            if (!userScrolling) {
                return;
            }
            interruptScrlWait = true;
            if (!waitingForScrl) {
                const container = document.getElementById('messages');
                if (container.scrollHeight - container.scrollTop <= container.clientHeight + 1) {
                    scrlAtBtm = true;
                    const bottomBtn = document.getElementById('goToBottom');
                    bottomBtn.style.display = 'none';
                } else {
                    scrlAtBtm = false;
                    const bottomBtn = document.getElementById('goToBottom');
                    bottomBtn.style.display = 'block';
                }
            }
            updateHei();
        }

        function updateHei() {
            const cont = document.getElementById('chatContainer');
            var hei = cont.offsetHeight + 17*2;
            const bottomCont = document.getElementById('goToBottomContainer');
            bottomCont.style.height = `calc(3em + ${hei}px)`
        }
        document.getElementById('chatIn').addEventListener("input", updateHei);

        function scrollMsgs() {
            const scrollable = document.getElementById('messages');
            scrollable.scrollTo({ top: scrollable.scrollHeight, behavior: 'smooth' });
            waitForScrollEnd(scrollable);
        }
        function waitForScrollEnd(container, wait = false) {
            interruptScrlWait = false;
            if (wait) {
                waitingForScrl = true;
            }
            const checkIfAtBottom = () => {
                if (interruptScrlWait) {
                    if (wait) {
                        scrollable.scrollTo({ top: scrollable.scrollHeight, behavior: 'smooth' });
                    } else {
                        return;
                    }
                }
                if (container.scrollTop + container.clientHeight >= container.scrollHeight - 1) {
                    container.scrollTop = container.scrollHeight;
                    const bottomBtn = document.getElementById('goToBottom');
                    bottomBtn.style.display = 'none';
                    scrlAtBtm = true;
                    waitingForScrl = false;
                } else {
                    requestAnimationFrame(checkIfAtBottom);
                }
            };
            requestAnimationFrame(checkIfAtBottom);
        }

        async function initAI() {
            disableInp();
            var msg = makeMessage('bot', '');
            var inn = msg.lastElementChild.firstElementChild;
            insertTemplate(inn, 'spinner');
            scrollMsgs(true);
            return msg;
        }
        async function startAI() {
            await stopAI();
            var msg = await initAI();
            const ID = this.location.pathname.split('/')[2];
            const response = await fetch('/api/v1/ai/start/'+ID, {
                method: 'POST',
                cache: "no-cache",
                headers: {
                    'Content-Type': "application/json"
                },
                body: JSON.stringify({
                    'conv': CONV, 
                    'modelStr': PROVIDER,
                    'opts': getOpts()
                })
            });
            streamAI(msg);
        }

        var lastMsg = "";
        var lastpfp = "";
        async function streamAI(msg = null) {
            if (!msg) {
                msg = await initAI();
            }
            const ID = this.location.pathname.split('/')[2];
            var pfpElm = msg.firstElementChild;
            var inn = msg.lastElementChild.firstElementChild;
            const response = await fetch('/api/v1/ai/stream/'+ID, {
                cache: "no-cache",
                keepalive: true,
                headers: {
                    'Accept': "text/event-stream",
                    'Content-Type': "application/json"
                }
            });
            const reader = response.body.getReader();

            var usingSpin = true;

            while (true) {
                var {value, done} = await reader.read();
                var newTxt = new TextDecoder().decode(value);
                var json = `{"data": [${newTxt.slice(0, -1)}]}`;
                var data = JSON.parse(json).data;

                var done = false;

                data.forEach(it => {
                    if (done) {
                        return;
                    }
                    if (usingSpin && (it.data !== '' || it.done)) {
                        usingSpin = false;
                        unuseTemplate('spinner');
                    }
                    getPfp(pfpElm, it.model);
                    formatText(inn.firstElementChild, it.data);
                    lastMsg = it.data;
                    lastpfp = it.model;
                    if (it.done) {
                        done = true;
                        return;
                    }
                    if (scrlAtBtm) {
                        scrollMsgs();
                    }
                });
                if (done) {
                    await stopAI();
                    return;
                }
            }
        }

        async function stopAI(addLast = true) {
            const ID = window.location.pathname.split('/')[2];
            var fail = false;
            var resp = await fetch('/api/v1/ai/stop/'+ID, {
                method: 'POST',
                cache: "no-cache",
            }).then((response) => {
                if (!response.ok) {
                    fail = true;
                }
            });
            if (fail) {
                return;
            }
            if (addLast) {
                CONV.push({role: 'bot', content: lastMsg});
            }
            await updateLastMessage(lastMsg, lastpfp);
            enableInp();
        }

        function disableInp() {
            const GOBtn = document.getElementById('chatGoBtn');
            GOBtn.firstElementChild.firstElementChild.setAttribute('href', '#stop');
            GOBtn.onclick = stopAI;
            const cont = document.getElementById('chatIn');
            cont.disabled = true;
        }
        function enableInp() {
            const GOBtn = document.getElementById('chatGoBtn');
            GOBtn.firstElementChild.firstElementChild.setAttribute('href', '#go');
            GOBtn.onclick = onChatGo;
            const cont = document.getElementById('chatIn');
            cont.disabled = false;
        }

        async function redo(elm, modif = 0) {
            // if (!confirm('You sure you want to redo?')) {
            //     return;
            // }
            await delElm(elm, false, modif);
            await startAI();
        }

        async function delElm(elm, ask = false, modif = 0) {
            if (ask && !confirm('Are you sure you want to delete this message AND ALL AFTER IT?')) {
                return;
            }
            await stopAI(false);
            const msgs = document.getElementById('messageBubbles');
            for (var i = CONV.length - 1; i >= 0; i--) {
                if (msgs.lastElementChild === elm.parentElement.parentElement.parentElement) {
                    if (modif == 0) {
                        msgs.removeChild(msgs.lastElementChild);
                    }

                    const ID = this.location.pathname.split('/')[2];
                    resp = await fetch('/api/v1/chat/'+ID, {
                        method: 'PUT',
                        headers: {
                            'Content-Type': 'application/json'
                        },
                        body: JSON.stringify({
                            'conv': CONV.slice(0, i+modif)
                        })
                    });
                    json = await resp.json();
                    if (json.status === 'error') {
                        console.error(json);
                        alert(json.message);
                        return;
                    }
                    CONV = json.data.messages;
                    break;
                }
                msgs.removeChild(msgs.lastElementChild);
            }
        }

        async function backElm(elm) {
            const msgs = document.getElementById('messageBubbles');
            const parent = elm.parentElement.parentElement.parentElement;
            const idx = Array.prototype.indexOf.call(msgs.children, parent);
            msgs.removeChild(parent);
            const ID = this.location.pathname.split('/')[2];
            const resp = await fetch('/api/v1/chat/'+ID, {
                method: 'PUT',
                headers: {
                    'Content-Type': 'application/json'
                },
                body: JSON.stringify({
                    'conv': [...CONV.slice(0, idx-1), ...CONV.slice(idx)]
                })
            });
            json = await resp.json();
            if (json.status === 'error') {
                console.error(json);
                alert(json.message);
                return;
            }
            CONV = json.data.messages;
        }

        function endEdit(elm, idx) {
            elm.innerHTML = '';
            const newSpan = document.createElement('span');
            formatText(newSpan, CONV[idx-1].content);
            elm.appendChild(newSpan);
        }
        async function editElm(elm) {
            const ID = this.location.pathname.split('/')[2];
            const msg = elm.parentElement.parentElement.parentElement
            const msgs = document.getElementById('messageBubbles');
            const idx = Array.prototype.indexOf.call(msgs.children, msg);
            const msgtxt = elm.parentElement.parentElement.firstElementChild;
            const newDiv = document.createElement('div');
            newDiv.innerText = CONV[idx-1].content;
            newDiv.contentEditable = "true";
            msgtxt.innerHTML = '';
            msgtxt.appendChild(newDiv);
            const btnsDiv = document.createElement('div');
            [['yes', async function(){
                var newConv = CONV.slice()
                newConv[idx-1].content = msgtxt.innerText;
                const resp = await fetch('/api/v1/chat/'+ID, {
                    method: 'PUT',
                    headers: {
                        'Content-Type': 'application/json'
                    },
                    body: JSON.stringify({
                        'conv': newConv
                    })
                });
                json = await resp.json();
                if (json.status === 'error') {
                    console.error(json);
                    alert(json.message);
                    return;
                }
                CONV = json.data.messages;
                endEdit(msgtxt, idx);
                await delElm(elm, false, 1);
                await startAI();
            }], 
             ['no', function(){ endEdit(msgtxt, idx)} ]].forEach(val => {
                let newBtn = document.createElement('button');
                newBtn.onclick = val[1];
                newBtn.innerHTML = `<svg width="22" height="22"> <use href="#${val[0]}" /> </svg>`;
                newBtn.classList.add('msgEditBtn');
                btnsDiv.appendChild(newBtn);
            })
            msgtxt.appendChild(btnsDiv);
        }

        async function onChatGo() {
            const txt = getChatTxt();
            if (txt === "") {
                return;
            }
            disableInp();
            if (txt.trim()) {
                await addMessage('user', txt);
            }
            setChatTxt("");
            scrollMsgs();
            await startAI();
        }

        async function loadData() {
            const ID = this.location.pathname.split('/')[2];

            var data;
            if (ID) {
                var resp = await fetch('/api/v1/chat/'+ID);
                data = await resp.json();
                if (data.status === 'error') {
                    console.error(data);
                    alert(data.message);
                    home();
                    return;
                }
            } else {
                console.error('No chat ID provided');
                alert('No chat ID provided');
                home();
                return;
            }
            CONV = data.data.messages;
            CONV.forEach(element => {
                makeMessage(element.role, element.content, false, element.pfp);
            });
            const scrollable = document.getElementById('messages');
            scrollable.scrollTop = scrollable.scrollHeight;
            waitForScrollEnd(scrollable);
            if (data.running) {
                disableInp();
                var msg = document.getElementById('messageBubbles').lastElementChild;
                if (msg.classList.contains('myOut')) {
                    msg = makeMessage('bot', '');
                }
                if (!data.data.messages[data.data.messages.length-1].content) {
                    var inn = msg.lastElementChild.firstElementChild;
                    insertTemplate(inn, 'spinner');
                }
                streamAI(msg);
            }
        }

        loadData();

        function fix_hei() {
            const cont = document.getElementById('chatContainer');
            const hei = cont.offsetHeight + 54;
            document.getElementById('spacer').style.height = hei + 'px';
        }
        fix_hei();
        document.getElementById('chatIn').addEventListener("input", function() {
            fix_hei();
        });
    </script>
</div>
